{"version":3,"sources":["wachiman.js"],"names":["_jsonwebtoken","_interopRequireDefault","require","_usuarioModel","vigilante","req","res","next","token","resultado","usuarioEncontrado","regeneratorRuntime","async","_context","prev","console","log","headers","authorization","abrupt","status","json","message","split","jsonwebtoken","verify","process","env","JWT_SECRET","awrap","Usuario","findById","jti","sent","Error","toJSON","t0","content","stop"],"mappings":"gGAAA,IAAAA,cAAAC,uBAAAC,QAAA,iBACAC,cAAAD,QAAA,qGAGO,SAAeE,UAAUC,EAAKC,EAAKC,GAAnC,IAAAC,EAAAC,EAAAC,EAAA,OAAAC,mBAAAC,MAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAN,MAAA,KAAA,EAAA,GACLQ,QAAQC,IAAI,wBAKPX,EAAIY,QAAQC,cANZ,CAAAL,EAAAN,KAAA,EAAA,MAAA,OAAAM,EAAAM,OAAA,SAOIb,EAAIc,OAAO,KAAKC,KAAK,CAC1BC,QAAS,+CARR,KAAA,EAAA,OAAAd,EAAAH,EAAAY,QAAAC,cAAAK,MAAA,KAAA,GAAAR,QAAAC,IAAAR,GAAAK,EAAAC,KAAA,EAAAL,EAAAe,cAAAA,QAAAC,OAAAjB,EAAAkB,QAAAC,IAAAC,YACLb,QAAAA,IAAAA,GADKF,EAAAN,KAAA,GAAAI,mBAAAkB,MAKLC,cAAAA,QAAAC,SAAAtB,EAAAuB,MALK,KAAA,GAAA,GAKLtB,EALKG,EAAAoB,KAAA,CAAApB,EAAAN,KAAA,GAAA,MAAA,MAAA,IAAA2B,MAAA,qBAAA,KAAA,GAQDZ,EAAAA,KAAAA,EAASa,SAoBX5B,IA5BGM,EAAAN,KAAA,GAAA,MAAA,KAAA,GAAA,OAAAM,EAAAC,KAAA,GAAAD,EAAAuB,GAAAvB,EAAA,MAAA,GAAAA,EAAAM,OAAA,SAYCX,EAZDY,OAYaH,KAAAA,KAAQC,CAC1BH,QAAAA,kBAbKsB,QAAAxB,EAAAuB,GAAAd,WAAA,KAAA,GAAA,IAAA,MAAA,OAAAT,EAAAyB,SAAA,KAAA,KAAA,CAAA,CAAA,EAAA","file":"wachiman.min.js","sourcesContent":["import jsonwebtoken from \"jsonwebtoken\";\r\nimport { Usuario } from \"../models/usuarioModel.js\";\r\n\r\n// Middleware => es un controlador intermedio que se encarga de validar que la operacion se realice correctamente, si algo esta mal o invalido lo detendra y no permitira que pase al siguiente controlador (el siguiente controlador puede ser otro middleware o el controlador final)\r\nexport async function vigilante(req, res, next) {\r\n  console.log(\"Yo soy un middleware\");\r\n  // next > si no le pasamos ningun parametro entonces dejara pasar, caso contrario detendra el ciclo y hasta ahi no mas llegara\r\n\r\n  // Primero verificamos que tengamos una token\r\n  // headers > cabecera de la token es ahi donde se envia el user-agent (host o servidor es), host (host del client) y otros headers que el cliente lo puede setear, aqui tbn se adjunta la autorizacion\r\n  if (!req.headers.authorization) {\r\n    return res.status(401).json({\r\n      message: \"Se necesita una token para esta operacion\",\r\n    });\r\n  }\r\n\r\n  const token = req.headers.authorization.split(\" \")[1];\r\n  console.log(token);\r\n  try {\r\n    const resultado = jsonwebtoken.verify(token, process.env.JWT_SECRET);\r\n    console.log(resultado);\r\n    //buscaremos a ese usuario\r\n    const usuarioEncontrado = await Usuario.findById(resultado.jti);\r\n\r\n    // si no existe el usuario entonces emitimos un error que ingresara al catch\r\n    if (!usuarioEncontrado) {\r\n      throw new Error(\"Usuario no existe\");\r\n    }\r\n\r\n    // agregar ese usuario al req.user para que pueda ser utilizado luego\r\n    req.user = usuarioEncontrado.toJSON();\r\n\r\n    next();\r\n  } catch (error) {\r\n    return res.status(400).json({\r\n      message: \" Token invalida\",\r\n      content: error.message,\r\n    });\r\n  }\r\n}"]}